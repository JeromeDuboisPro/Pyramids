<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pyramids - Sphere Rendering Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000510;
            color: white;
            overflow-x: hidden;
        }

        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 5, 16, 0.95);
            padding: 20px;
            z-index: 1000;
            border-bottom: 2px solid #FF6B35;
        }

        #header h1 {
            font-size: 24px;
            color: #FF6B35;
            margin-bottom: 10px;
        }

        #set-info {
            font-size: 16px;
            color: #00D9FF;
            margin-bottom: 10px;
            font-weight: bold;
        }

        #header p {
            font-size: 14px;
            color: #808080;
            margin-bottom: 15px;
        }

        #selected-count {
            color: #00D9FF;
            font-weight: bold;
        }

        #controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            background: #1a1a2e;
            color: white;
            border: 2px solid #FF6B35;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            transition: all 0.3s;
        }

        .btn:hover {
            background: #FF6B35;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn:disabled:hover {
            background: #1a1a2e;
            transform: none;
        }

        #grid-container {
            margin-top: 200px;
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            max-width: 1600px;
            margin-left: auto;
            margin-right: auto;
        }

        .sphere-card {
            background: #0f0f1e;
            border: 2px solid #1a1a2e;
            border-radius: 10px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .sphere-card:hover {
            border-color: #FF6B35;
            transform: translateY(-5px);
        }

        .sphere-card.selected {
            border-color: #00D9FF;
            background: rgba(0, 217, 255, 0.1);
        }

        .sphere-card canvas {
            width: 100%;
            height: 200px;
            display: block;
        }

        .sphere-info {
            padding: 10px;
            text-align: center;
        }

        .sphere-id {
            font-size: 20px;
            font-weight: bold;
            color: #FF6B35;
            margin-bottom: 5px;
        }

        .sphere-name {
            font-size: 14px;
            color: white;
            margin-bottom: 5px;
        }

        .sphere-tech {
            font-size: 11px;
            color: #808080;
            line-height: 1.4;
        }

        .selection-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #00D9FF;
            color: #000510;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
        }

        .sphere-card.selected .selection-badge {
            display: flex;
        }

        @media (max-width: 1200px) {
            #grid-container {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 800px) {
            #grid-container {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>üé® Sphere Rendering Test - Intel iGPU Compatibility</h1>
        <div id="set-info">Set <span id="current-set">1</span> of <span id="total-sets">2</span></div>
        <p>Click on spheres to select your favorites. Selected: <span id="selected-count">0</span>/16</p>
        <div id="controls">
            <button class="btn" id="prev-set-btn" disabled>‚Üê Previous Set</button>
            <button class="btn" id="next-set-btn">Next Set ‚Üí</button>
            <button class="btn" id="clear-btn">Clear Selection</button>
            <button class="btn" id="show-selected-btn" disabled>Show Selected IDs</button>
            <button class="btn" id="back-game-btn">‚Üê Back to Game</button>
        </div>
    </div>

    <div id="grid-container"></div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        // Design Sets
        const designSets = [
            // SET 1: Original 16 designs
            {
                name: "Initial Exploration",
                designs: [
                    { id: 'A1', name: 'Current Design', tech: 'Glass shell + glowing core (MeshStandard)', create: createCurrentDesign },
                    { id: 'A2', name: 'Solid Emissive', tech: 'Single sphere, high emissive (MeshStandard)', create: createSolidEmissive },
                    { id: 'A3', name: 'Layered Glow', tech: 'Core + 2 glow layers (additive blending)', create: createLayeredGlow },
                    { id: 'A4', name: 'Sprite Glow', tech: 'Sphere + sprite-based halo', create: createSpriteGlow },
                    { id: 'B1', name: 'Point Light Focus', tech: 'Dim sphere + strong point light', create: createPointLightFocus },
                    { id: 'B2', name: 'Particle Core', tech: 'Sphere + particle system inside', create: createParticleCore },
                    { id: 'B3', name: 'Fresnel Rim', tech: 'Shader-based rim lighting simulation', create: createFresnelRim },
                    { id: 'B4', name: 'Double Shell', tech: 'Two transparent spheres, different sizes', create: createDoubleShell },
                    { id: 'C1', name: 'Basic Lit', tech: 'MeshBasicMaterial + external lighting', create: createBasicLit },
                    { id: 'C2', name: 'Metallic Sphere', tech: 'High metalness + roughness variation', create: createMetallic },
                    { id: 'C3', name: 'Flat + Shadow', tech: 'Flat color + fake shadow plane', create: createFlatShadow },
                    { id: 'C4', name: 'Pulsing Scale', tech: 'Size animation focus, minimal glow', create: createPulsingScale },
                    { id: 'D1', name: 'Ring Effect', tech: 'Sphere + Saturn-like ring', create: createRingEffect },
                    { id: 'D2', name: 'Multi-Light', tech: 'Multiple small point lights around sphere', create: createMultiLight },
                    { id: 'D3', name: 'Bloom Sim', tech: 'Bright core + multiple blur layers', create: createBloomSim },
                    { id: 'D4', name: 'Gradient Texture', tech: 'Radial gradient canvas texture', create: createGradientTexture }
                ]
            },
            // SET 2: Iterations on A2, B2, C4, D1 (user favorites)
            {
                name: "Refined Favorites (A2, B2, C4, D1 variations)",
                designs: [
                    { id: 'A2-1', name: 'Solid Emissive+', tech: 'A2 + subtle pulse + higher intensity', create: createSolidEmissivePlus },
                    { id: 'A2-2', name: 'Solid Dual-Tone', tech: 'A2 + emissive + color variation', create: createSolidDualTone },
                    { id: 'A2-3', name: 'Solid + Halo', tech: 'A2 + transparent outer halo layer', create: createSolidHalo },
                    { id: 'A2-4', name: 'Solid Pulsing', tech: 'A2 + dramatic pulse animation', create: createSolidPulsing },
                    { id: 'B2-1', name: 'Dense Particles', tech: 'B2 + 2x particle count, slower motion', create: createDenseParticles },
                    { id: 'B2-2', name: 'Particle Flow', tech: 'B2 + directional particle movement', create: createParticleFlow },
                    { id: 'B2-3', name: 'Particle Shell', tech: 'B2 + particles on sphere surface', create: createParticleShell },
                    { id: 'B2-4', name: 'Particle Burst', tech: 'B2 + expanding particle effect', create: createParticleBurst },
                    { id: 'C4-1', name: 'Pulse + Glow', tech: 'C4 + emissive core, larger scale', create: createPulseGlow },
                    { id: 'C4-2', name: 'Pulse + Wobble', tech: 'C4 + scale + slight deformation', create: createPulseWobble },
                    { id: 'C4-3', name: 'Elastic Pulse', tech: 'C4 + bounce-like scale animation', create: createElasticPulse },
                    { id: 'C4-4', name: 'Breath Pulse', tech: 'C4 + slow, organic breathing motion', create: createBreathPulse },
                    { id: 'D1-1', name: 'Thick Ring', tech: 'D1 + wider ring, more opacity', create: createThickRing },
                    { id: 'D1-2', name: 'Double Ring', tech: 'D1 + two rings at different angles', create: createDoubleRing },
                    { id: 'D1-3', name: 'Rotating Ring', tech: 'D1 + ring rotation animation', create: createRotatingRing },
                    { id: 'D1-4', name: 'Glowing Ring', tech: 'D1 + emissive ring material', create: createGlowingRing }
                ]
            },
            // SET 3: Ultra-refined (A2-3, B2-3, C4-3 deep variations)
            {
                name: "Final Refinements (A2-3, B2-3, C4-3 mastery)",
                designs: [
                    { id: 'A3-1', name: 'Tight Halo', tech: 'A2-3 + smaller, brighter halo', create: createTightHalo },
                    { id: 'A3-2', name: 'Wide Halo', tech: 'A2-3 + larger, softer halo', create: createWideHalo },
                    { id: 'A3-3', name: 'Pulsing Halo', tech: 'A2-3 + animated halo pulse', create: createPulsingHalo },
                    { id: 'A3-4', name: 'Dual Halo', tech: 'A2-3 + two halo layers', create: createDualHalo },
                    { id: 'A3-5', name: 'Color Shift Halo', tech: 'A2-3 + gradient halo effect', create: createColorShiftHalo },
                    { id: 'B3-1', name: 'Dense Shell', tech: 'B2-3 + 2x particle density', create: createDenseShell },
                    { id: 'B3-2', name: 'Sparse Shell', tech: 'B2-3 + fewer, larger particles', create: createSparseShell },
                    { id: 'B3-3', name: 'Rotating Shell', tech: 'B2-3 + particle rotation', create: createRotatingShell },
                    { id: 'B3-4', name: 'Pulsing Shell', tech: 'B2-3 + radial pulse animation', create: createPulsingShell },
                    { id: 'B3-5', name: 'Layered Shell', tech: 'B2-3 + multiple particle layers', create: createLayeredShell },
                    { id: 'C3-1', name: 'Fast Elastic', tech: 'C4-3 + faster bounce speed', create: createFastElastic },
                    { id: 'C3-2', name: 'Gentle Elastic', tech: 'C4-3 + slower, smoother bounce', create: createGentleElastic },
                    { id: 'C3-3', name: 'Extreme Elastic', tech: 'C4-3 + large scale variation', create: createExtremeElastic },
                    { id: 'C3-4', name: 'Damped Elastic', tech: 'C4-3 + damping effect', create: createDampedElastic },
                    { id: 'C3-5', name: 'Spring Elastic', tech: 'C4-3 + spring physics', create: createSpringElastic },
                    { id: 'X1', name: 'Hybrid Masterpiece', tech: 'Halo + Particle Shell + Elastic', create: createHybridMasterpiece }
                ]
            },
            // SET 4: Final polish (A3-3, A3-5, B3-5, X1 perfection)
            {
                name: "The Final Four (Master designs)",
                designs: [
                    { id: 'A4-1', name: 'Fast Pulse Halo', tech: 'A3-3 + faster pulse speed', create: createFastPulseHalo },
                    { id: 'A4-2', name: 'Slow Breath Halo', tech: 'A3-3 + slow breathing pulse', create: createSlowBreathHalo },
                    { id: 'A4-3', name: 'Double Pulse Halo', tech: 'A3-3 + core + halo pulse together', create: createDoublePulseHalo },
                    { id: 'A5-1', name: 'Warm Gradient', tech: 'A3-5 + orange‚Üíred‚Üípink gradient', create: createWarmGradient },
                    { id: 'A5-2', name: 'Cool Gradient', tech: 'A3-5 + orange‚Üíblue‚Üícyan gradient', create: createCoolGradient },
                    { id: 'A5-3', name: 'Rainbow Halo', tech: 'A3-5 + multi-color gradient', create: createRainbowHalo },
                    { id: 'A5-4', name: 'Animated Gradient', tech: 'A3-5 + rotating color shift', create: createAnimatedGradient },
                    { id: 'A5-5', name: 'Plasma Halo', tech: 'A3-5 + plasma-like color effect', create: createPlasmaHalo },
                    { id: 'B5-1', name: '4-Layer Shell', tech: 'B3-5 + one more particle layer', create: create4LayerShell },
                    { id: 'B5-2', name: 'Reverse Layers', tech: 'B3-5 + layers rotate opposite', create: createReverseLayers },
                    { id: 'B5-3', name: 'Pulsing Layers', tech: 'B3-5 + layers pulse radially', create: createPulsingLayers },
                    { id: 'X2', name: 'Hybrid v2', tech: 'X1 + gradient halo', create: createHybridV2 },
                    { id: 'X3', name: 'Hybrid v3', tech: 'X1 + 4 particle layers', create: createHybridV3 },
                    { id: 'X4', name: 'Hybrid Elite', tech: 'X1 + gradient + 4 layers + spring', create: createHybridElite },
                    { id: 'X5', name: 'Hybrid Ultimate', tech: 'All techniques combined, polished', create: createHybridUltimate },
                    { id: 'FINAL', name: 'The One', tech: 'Perfect synthesis of all learnings', create: createTheOne }
                ]
            }
        ];

        let currentSetIndex = 0;
        let selectedDesigns = new Set();
        let activeScenes = [];

        // Create design functions for SET 1
        function createCurrentDesign(scene) {
            const group = new THREE.Group();
            const shell = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.4,
                    metalness: 0.1,
                    roughness: 0.2
                })
            );
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 2.0
                })
            );
            core.userData.isCore = true;
            group.add(shell);
            group.add(core);
            const light = new THREE.PointLight(0xFF6B35, 1.5, 5);
            group.add(light);
            scene.add(group);
            return group;
        }

        function createSolidEmissive(scene) {
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0,
                    metalness: 0,
                    roughness: 0.3
                })
            );
            sphere.userData.isCore = true;
            scene.add(sphere);
            return sphere;
        }

        function createLayeredGlow(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 2.5
                })
            );
            core.userData.isCore = true;
            const glow1 = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                })
            );
            const glow2 = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.15,
                    blending: THREE.AdditiveBlending
                })
            );
            group.add(core);
            group.add(glow1);
            group.add(glow2);
            scene.add(group);
            return group;
        }

        function createSpriteGlow(scene) {
            const group = new THREE.Group();
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.5
                })
            );
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255, 107, 53, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 107, 53, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 128);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                blending: THREE.AdditiveBlending
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(1.5, 1.5, 1);
            group.add(sphere);
            group.add(sprite);
            scene.add(group);
            return group;
        }

        function createPointLightFocus(scene) {
            const group = new THREE.Group();
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 0.3
                })
            );
            const light = new THREE.PointLight(0xFF6B35, 3.0, 8);
            group.add(sphere);
            group.add(light);
            scene.add(group);
            return group;
        }

        function createParticleCore(scene) {
            const group = new THREE.Group();
            const shell = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.3
                })
            );
            const particleCount = 100;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 0.6;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xFF6B35,
                size: 0.05,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const particles = new THREE.Points(geometry, material);
            particles.userData.isParticles = true;
            group.add(shell);
            group.add(particles);
            scene.add(group);
            return group;
        }

        function createFresnelRim(scene) {
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0x331100,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.2
                })
            );
            sphere.userData.isCore = true;
            scene.add(sphere);
            return sphere;
        }

        function createDoubleShell(scene) {
            const group = new THREE.Group();
            const inner = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.6,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.0
                })
            );
            const outer = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.2
                })
            );
            group.add(inner);
            group.add(outer);
            scene.add(group);
            return group;
        }

        function createBasicLit(scene) {
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35
                })
            );
            scene.add(sphere);
            return sphere;
        }

        function createMetallic(scene) {
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    metalness: 0.9,
                    roughness: 0.3,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 0.5
                })
            );
            scene.add(sphere);
            return sphere;
        }

        function createFlatShadow(scene) {
            const group = new THREE.Group();
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35
                })
            );
            const shadow = new THREE.Mesh(
                new THREE.CircleGeometry(0.6, 32),
                new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.3
                })
            );
            shadow.rotation.x = -Math.PI / 2;
            shadow.position.y = -0.5;
            group.add(sphere);
            group.add(shadow);
            scene.add(group);
            return group;
        }

        function createPulsingScale(scene) {
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 0.5
                })
            );
            sphere.userData.isPulsing = true;
            scene.add(sphere);
            return sphere;
        }

        function createRingEffect(scene) {
            const group = new THREE.Group();
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.5
                })
            );
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.6, 0.8, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                })
            );
            ring.rotation.x = Math.PI / 4;
            ring.userData.isRing = true;
            group.add(sphere);
            group.add(ring);
            scene.add(group);
            return group;
        }

        function createMultiLight(scene) {
            const group = new THREE.Group();
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35
                })
            );
            group.add(sphere);
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const light = new THREE.PointLight(0xFF6B35, 1.0, 3);
                light.position.set(Math.cos(angle) * 0.6, 0, Math.sin(angle) * 0.6);
                group.add(light);
            }
            scene.add(group);
            return group;
        }

        function createBloomSim(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.25, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            for (let i = 0; i < 3; i++) {
                const blur = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3 + i * 0.1, 16, 16),
                    new THREE.MeshBasicMaterial({
                        color: 0xFF6B35,
                        transparent: true,
                        opacity: 0.2 - i * 0.05,
                        blending: THREE.AdditiveBlending
                    })
                );
                group.add(blur);
            }
            group.add(core);
            scene.add(group);
            return group;
        }

        function createGradientTexture(scene) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
            gradient.addColorStop(0, '#FF6B35');
            gradient.addColorStop(1, '#331100');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
            const texture = new THREE.CanvasTexture(canvas);
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 64, 64),
                new THREE.MeshStandardMaterial({
                    map: texture,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 0.5
                })
            );
            scene.add(sphere);
            return sphere;
        }

        // SET 2: Refined variations
        function createSolidEmissivePlus(scene) {
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 4.0,
                    metalness: 0,
                    roughness: 0.2
                })
            );
            sphere.userData.isCore = true;
            sphere.userData.pulseFast = true;
            scene.add(sphere);
            return sphere;
        }

        function createSolidDualTone(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 3.0
                })
            );
            const shell = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.5,
                    transparent: true,
                    opacity: 0.7
                })
            );
            core.userData.isCore = true;
            group.add(core);
            group.add(shell);
            scene.add(group);
            return group;
        }

        function createSolidHalo(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.2,
                    blending: THREE.AdditiveBlending
                })
            );
            core.userData.isCore = true;
            group.add(core);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function createSolidPulsing(scene) {
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            sphere.userData.isCore = true;
            sphere.userData.pulseDramatic = true;
            scene.add(sphere);
            return sphere;
        }

        function createDenseParticles(scene) {
            const group = new THREE.Group();
            const shell = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.25
                })
            );
            const particleCount = 200;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 0.7;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xFF6B35,
                size: 0.04,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });
            const particles = new THREE.Points(geometry, material);
            particles.userData.isParticles = true;
            particles.userData.slowMotion = true;
            group.add(shell);
            group.add(particles);
            scene.add(group);
            return group;
        }

        function createParticleFlow(scene) {
            const group = new THREE.Group();
            const shell = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.3
                })
            );
            const particleCount = 150;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2;
                const radius = 0.3 + Math.random() * 0.2;
                positions[i * 3] = Math.cos(angle) * radius;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 0.4;
                positions[i * 3 + 2] = Math.sin(angle) * radius;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xFF6B35,
                size: 0.05,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const particles = new THREE.Points(geometry, material);
            particles.userData.isParticles = true;
            particles.userData.flowPattern = true;
            group.add(shell);
            group.add(particles);
            scene.add(group);
            return group;
        }

        function createParticleShell(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.5
                })
            );
            const particleCount = 120;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const radius = 0.5;
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xFF6B35,
                size: 0.06,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            const particles = new THREE.Points(geometry, material);
            particles.userData.isParticles = true;
            group.add(core);
            group.add(particles);
            scene.add(group);
            return group;
        }

        function createParticleBurst(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 2.0
                })
            );
            const particleCount = 80;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 0.4;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xFF6B35,
                size: 0.07,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });
            const particles = new THREE.Points(geometry, material);
            particles.userData.isParticles = true;
            particles.userData.burstPattern = true;
            group.add(core);
            group.add(particles);
            scene.add(group);
            return group;
        }

        function createPulseGlow(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 2.5
                })
            );
            core.userData.isCore = true;
            const shell = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.3
                })
            );
            shell.userData.isPulsing = true;
            shell.userData.largeScale = true;
            group.add(core);
            group.add(shell);
            scene.add(group);
            return group;
        }

        function createPulseWobble(scene) {
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.0
                })
            );
            sphere.userData.isPulsing = true;
            sphere.userData.wobble = true;
            scene.add(sphere);
            return sphere;
        }

        function createElasticPulse(scene) {
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.0
                })
            );
            sphere.userData.isPulsing = true;
            sphere.userData.elastic = true;
            scene.add(sphere);
            return sphere;
        }

        function createBreathPulse(scene) {
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.2
                })
            );
            sphere.userData.isPulsing = true;
            sphere.userData.breath = true;
            scene.add(sphere);
            return sphere;
        }

        function createThickRing(scene) {
            const group = new THREE.Group();
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.5
                })
            );
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.55, 0.85, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                })
            );
            ring.rotation.x = Math.PI / 4;
            ring.userData.isRing = true;
            group.add(sphere);
            group.add(ring);
            scene.add(group);
            return group;
        }

        function createDoubleRing(scene) {
            const group = new THREE.Group();
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.5
                })
            );
            const ring1 = new THREE.Mesh(
                new THREE.RingGeometry(0.6, 0.75, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                })
            );
            ring1.rotation.x = Math.PI / 4;
            ring1.userData.isRing = true;
            const ring2 = new THREE.Mesh(
                new THREE.RingGeometry(0.6, 0.75, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                })
            );
            ring2.rotation.x = -Math.PI / 4;
            ring2.rotation.z = Math.PI / 2;
            ring2.userData.isRing = true;
            group.add(sphere);
            group.add(ring1);
            group.add(ring2);
            scene.add(group);
            return group;
        }

        function createRotatingRing(scene) {
            const group = new THREE.Group();
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.5
                })
            );
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.6, 0.8, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                })
            );
            ring.rotation.x = Math.PI / 2;
            ring.userData.isRing = true;
            ring.userData.rotating = true;
            group.add(sphere);
            group.add(ring);
            scene.add(group);
            return group;
        }

        function createGlowingRing(scene) {
            const group = new THREE.Group();
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.5
                })
            );
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.6, 0.8, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 2.0,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                })
            );
            ring.rotation.x = Math.PI / 4;
            ring.userData.isRing = true;
            ring.userData.glowing = true;
            group.add(sphere);
            group.add(ring);
            scene.add(group);
            return group;
        }

        // SET 3: Ultra-refined variations
        function createTightHalo(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.5
                })
            );
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending
                })
            );
            core.userData.isCore = true;
            group.add(core);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function createWideHalo(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.7, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.15,
                    blending: THREE.AdditiveBlending
                })
            );
            core.userData.isCore = true;
            group.add(core);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function createPulsingHalo(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.2,
                    blending: THREE.AdditiveBlending
                })
            );
            core.userData.isCore = true;
            halo.userData.isPulsing = true;
            halo.userData.largeScale = true;
            group.add(core);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function createDualHalo(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            const halo1 = new THREE.Mesh(
                new THREE.SphereGeometry(0.55, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                })
            );
            const halo2 = new THREE.Mesh(
                new THREE.SphereGeometry(0.7, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.15,
                    blending: THREE.AdditiveBlending
                })
            );
            core.userData.isCore = true;
            group.add(core);
            group.add(halo1);
            group.add(halo2);
            scene.add(group);
            return group;
        }

        function createColorShiftHalo(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(128, 128, 50, 128, 128, 128);
            gradient.addColorStop(0, 'rgba(255, 107, 53, 0.6)');
            gradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 107, 53, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
            const texture = new THREE.CanvasTexture(canvas);
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.65, 32, 32),
                new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                })
            );
            core.userData.isCore = true;
            group.add(core);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function createDenseShell(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.5
                })
            );
            const particleCount = 240;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const radius = 0.5;
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xFF6B35,
                size: 0.04,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const particles = new THREE.Points(geometry, material);
            particles.userData.isParticles = true;
            group.add(core);
            group.add(particles);
            scene.add(group);
            return group;
        }

        function createSparseShell(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.5
                })
            );
            const particleCount = 60;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const radius = 0.5;
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xFF6B35,
                size: 0.1,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });
            const particles = new THREE.Points(geometry, material);
            particles.userData.isParticles = true;
            group.add(core);
            group.add(particles);
            scene.add(group);
            return group;
        }

        function createRotatingShell(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.5
                })
            );
            const particleCount = 120;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const radius = 0.5;
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xFF6B35,
                size: 0.06,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            const particles = new THREE.Points(geometry, material);
            particles.userData.isParticles = true;
            particles.userData.rotating = true;
            group.add(core);
            group.add(particles);
            scene.add(group);
            return group;
        }

        function createPulsingShell(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.5
                })
            );
            const particleCount = 120;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const radius = 0.5;
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xFF6B35,
                size: 0.06,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            const particles = new THREE.Points(geometry, material);
            particles.userData.isParticles = true;
            particles.userData.radialPulse = true;
            group.add(core);
            group.add(particles);
            scene.add(group);
            return group;
        }

        function createLayeredShell(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 2.0
                })
            );
            group.add(core);

            // Three particle layers at different radii
            [0.4, 0.5, 0.6].forEach((radius, layerIndex) => {
                const particleCount = 80 - layerIndex * 20;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount; i++) {
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = Math.random() * Math.PI * 2;
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({
                    color: 0xFF6B35,
                    size: 0.05 + layerIndex * 0.01,
                    transparent: true,
                    opacity: 0.8 - layerIndex * 0.15,
                    blending: THREE.AdditiveBlending
                });
                const particles = new THREE.Points(geometry, material);
                particles.userData.isParticles = true;
                particles.userData.layerSpeed = 0.2 + layerIndex * 0.1;
                group.add(particles);
            });

            scene.add(group);
            return group;
        }

        function createFastElastic(scene) {
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.0
                })
            );
            sphere.userData.isPulsing = true;
            sphere.userData.elastic = true;
            sphere.userData.fastSpeed = true;
            scene.add(sphere);
            return sphere;
        }

        function createGentleElastic(scene) {
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.0
                })
            );
            sphere.userData.isPulsing = true;
            sphere.userData.elastic = true;
            sphere.userData.gentle = true;
            scene.add(sphere);
            return sphere;
        }

        function createExtremeElastic(scene) {
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.0
                })
            );
            sphere.userData.isPulsing = true;
            sphere.userData.elastic = true;
            sphere.userData.extreme = true;
            scene.add(sphere);
            return sphere;
        }

        function createDampedElastic(scene) {
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.0
                })
            );
            sphere.userData.isPulsing = true;
            sphere.userData.elastic = true;
            sphere.userData.damped = true;
            scene.add(sphere);
            return sphere;
        }

        function createSpringElastic(scene) {
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 1.0
                })
            );
            sphere.userData.isPulsing = true;
            sphere.userData.elastic = true;
            sphere.userData.spring = true;
            scene.add(sphere);
            return sphere;
        }

        function createHybridMasterpiece(scene) {
            const group = new THREE.Group();

            // Core
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            core.userData.isCore = true;

            // Halo
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.65, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.2,
                    blending: THREE.AdditiveBlending
                })
            );
            halo.userData.isPulsing = true;
            halo.userData.largeScale = true;

            // Particle Shell
            const particleCount = 120;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const radius = 0.5;
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xFF6B35,
                size: 0.06,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            const particles = new THREE.Points(geometry, material);
            particles.userData.isParticles = true;

            // Elastic shell
            const elasticShell = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.3
                })
            );
            elasticShell.userData.isPulsing = true;
            elasticShell.userData.elastic = true;

            group.add(core);
            group.add(elasticShell);
            group.add(particles);
            group.add(halo);
            scene.add(group);
            return group;
        }

        // SET 4: Final polish variations
        function createFastPulseHalo(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.2,
                    blending: THREE.AdditiveBlending
                })
            );
            core.userData.isCore = true;
            halo.userData.isPulsing = true;
            halo.userData.largeScale = true;
            halo.userData.fastPulse = true;
            group.add(core);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function createSlowBreathHalo(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.2,
                    blending: THREE.AdditiveBlending
                })
            );
            core.userData.isCore = true;
            halo.userData.isPulsing = true;
            halo.userData.breath = true;
            group.add(core);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function createDoublePulseHalo(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            core.userData.isCore = true;
            core.userData.pulseDramatic = true;
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.2,
                    blending: THREE.AdditiveBlending
                })
            );
            halo.userData.isPulsing = true;
            halo.userData.largeScale = true;
            group.add(core);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function createWarmGradient(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(128, 128, 40, 128, 128, 128);
            gradient.addColorStop(0, 'rgba(255, 107, 53, 0.7)');
            gradient.addColorStop(0.4, 'rgba(255, 80, 80, 0.5)');
            gradient.addColorStop(0.7, 'rgba(255, 150, 180, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 107, 53, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
            const texture = new THREE.CanvasTexture(canvas);
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.65, 32, 32),
                new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                })
            );
            core.userData.isCore = true;
            group.add(core);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function createCoolGradient(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(128, 128, 40, 128, 128, 128);
            gradient.addColorStop(0, 'rgba(255, 107, 53, 0.7)');
            gradient.addColorStop(0.4, 'rgba(100, 180, 255, 0.5)');
            gradient.addColorStop(0.7, 'rgba(0, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 107, 53, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
            const texture = new THREE.CanvasTexture(canvas);
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.65, 32, 32),
                new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                })
            );
            core.userData.isCore = true;
            group.add(core);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function createRainbowHalo(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(128, 128, 40, 128, 128, 128);
            gradient.addColorStop(0, 'rgba(255, 107, 53, 0.7)');
            gradient.addColorStop(0.2, 'rgba(255, 200, 100, 0.6)');
            gradient.addColorStop(0.4, 'rgba(100, 255, 100, 0.5)');
            gradient.addColorStop(0.6, 'rgba(100, 200, 255, 0.4)');
            gradient.addColorStop(0.8, 'rgba(200, 100, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 107, 53, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
            const texture = new THREE.CanvasTexture(canvas);
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.65, 32, 32),
                new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                })
            );
            core.userData.isCore = true;
            group.add(core);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function createAnimatedGradient(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(128, 128, 50, 128, 128, 128);
            gradient.addColorStop(0, 'rgba(255, 107, 53, 0.6)');
            gradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 107, 53, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
            const texture = new THREE.CanvasTexture(canvas);
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.65, 32, 32),
                new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                })
            );
            halo.userData.rotatingHalo = true;
            core.userData.isCore = true;
            group.add(core);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function createPlasmaHalo(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            // Create plasma-like pattern
            for (let x = 0; x < 256; x++) {
                for (let y = 0; y < 256; y++) {
                    const dx = x - 128;
                    const dy = y - 128;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    const value = Math.sin(dist * 0.05 + angle * 3);
                    const alpha = Math.max(0, (1 - dist / 128) * 0.6);
                    const r = 255;
                    const g = Math.floor(107 + value * 100);
                    const b = Math.floor(53 + value * 50);
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.65, 32, 32),
                new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                })
            );
            halo.userData.rotatingHalo = true;
            core.userData.isCore = true;
            group.add(core);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function create4LayerShell(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 2.0
                })
            );
            group.add(core);

            // Four particle layers
            [0.38, 0.46, 0.54, 0.62].forEach((radius, layerIndex) => {
                const particleCount = 90 - layerIndex * 15;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount; i++) {
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = Math.random() * Math.PI * 2;
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({
                    color: 0xFF6B35,
                    size: 0.04 + layerIndex * 0.01,
                    transparent: true,
                    opacity: 0.9 - layerIndex * 0.15,
                    blending: THREE.AdditiveBlending
                });
                const particles = new THREE.Points(geometry, material);
                particles.userData.isParticles = true;
                particles.userData.layerSpeed = 0.15 + layerIndex * 0.1;
                group.add(particles);
            });

            scene.add(group);
            return group;
        }

        function createReverseLayers(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 2.0
                })
            );
            group.add(core);

            [0.4, 0.5, 0.6].forEach((radius, layerIndex) => {
                const particleCount = 80 - layerIndex * 20;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount; i++) {
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = Math.random() * Math.PI * 2;
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({
                    color: 0xFF6B35,
                    size: 0.05 + layerIndex * 0.01,
                    transparent: true,
                    opacity: 0.8 - layerIndex * 0.15,
                    blending: THREE.AdditiveBlending
                });
                const particles = new THREE.Points(geometry, material);
                particles.userData.isParticles = true;
                // Alternating directions
                particles.userData.layerSpeed = layerIndex % 2 === 0 ? 0.3 : -0.3;
                group.add(particles);
            });

            scene.add(group);
            return group;
        }

        function createPulsingLayers(scene) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 2.0
                })
            );
            group.add(core);

            [0.4, 0.5, 0.6].forEach((radius, layerIndex) => {
                const particleCount = 80 - layerIndex * 20;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount; i++) {
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = Math.random() * Math.PI * 2;
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({
                    color: 0xFF6B35,
                    size: 0.05 + layerIndex * 0.01,
                    transparent: true,
                    opacity: 0.8 - layerIndex * 0.15,
                    blending: THREE.AdditiveBlending
                });
                const particles = new THREE.Points(geometry, material);
                particles.userData.isParticles = true;
                particles.userData.radialPulse = true;
                particles.userData.layerSpeed = 0.2 + layerIndex * 0.1;
                group.add(particles);
            });

            scene.add(group);
            return group;
        }

        function createHybridV2(scene) {
            const group = new THREE.Group();

            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            core.userData.isCore = true;

            // Gradient halo (instead of solid)
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(128, 128, 50, 128, 128, 128);
            gradient.addColorStop(0, 'rgba(255, 107, 53, 0.5)');
            gradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 107, 53, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
            const texture = new THREE.CanvasTexture(canvas);
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.65, 32, 32),
                new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                })
            );
            halo.userData.isPulsing = true;
            halo.userData.largeScale = true;

            const particleCount = 120;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const radius = 0.5;
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xFF6B35,
                size: 0.06,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            const particles = new THREE.Points(geometry, material);
            particles.userData.isParticles = true;

            const elasticShell = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.3
                })
            );
            elasticShell.userData.isPulsing = true;
            elasticShell.userData.elastic = true;

            group.add(core);
            group.add(elasticShell);
            group.add(particles);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function createHybridV3(scene) {
            const group = new THREE.Group();

            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.0
                })
            );
            core.userData.isCore = true;
            group.add(core);

            // 4 particle layers
            [0.38, 0.46, 0.54, 0.62].forEach((radius, layerIndex) => {
                const particleCount = 80 - layerIndex * 15;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount; i++) {
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = Math.random() * Math.PI * 2;
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({
                    color: 0xFF6B35,
                    size: 0.04 + layerIndex * 0.01,
                    transparent: true,
                    opacity: 0.9 - layerIndex * 0.15,
                    blending: THREE.AdditiveBlending
                });
                const particles = new THREE.Points(geometry, material);
                particles.userData.isParticles = true;
                particles.userData.layerSpeed = 0.15 + layerIndex * 0.1;
                group.add(particles);
            });

            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.7, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.15,
                    blending: THREE.AdditiveBlending
                })
            );
            halo.userData.isPulsing = true;
            halo.userData.largeScale = true;

            const elasticShell = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.25
                })
            );
            elasticShell.userData.isPulsing = true;
            elasticShell.userData.elastic = true;

            group.add(elasticShell);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function createHybridElite(scene) {
            const group = new THREE.Group();

            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.5
                })
            );
            core.userData.isCore = true;
            group.add(core);

            // 4 particle layers
            [0.38, 0.46, 0.54, 0.62].forEach((radius, layerIndex) => {
                const particleCount = 80 - layerIndex * 15;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount; i++) {
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = Math.random() * Math.PI * 2;
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({
                    color: 0xFF6B35,
                    size: 0.04 + layerIndex * 0.01,
                    transparent: true,
                    opacity: 0.9 - layerIndex * 0.15,
                    blending: THREE.AdditiveBlending
                });
                const particles = new THREE.Points(geometry, material);
                particles.userData.isParticles = true;
                particles.userData.layerSpeed = 0.15 + layerIndex * 0.1;
                group.add(particles);
            });

            // Gradient halo
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(128, 128, 50, 128, 128, 128);
            gradient.addColorStop(0, 'rgba(255, 107, 53, 0.5)');
            gradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 107, 53, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
            const texture = new THREE.CanvasTexture(canvas);
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.7, 32, 32),
                new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                })
            );
            halo.userData.isPulsing = true;
            halo.userData.largeScale = true;

            const elasticShell = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.25
                })
            );
            elasticShell.userData.isPulsing = true;
            elasticShell.userData.elastic = true;
            elasticShell.userData.spring = true;

            group.add(elasticShell);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function createHybridUltimate(scene) {
            const group = new THREE.Group();

            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 4.0
                })
            );
            core.userData.isCore = true;
            core.userData.pulseDramatic = true;
            group.add(core);

            // 4 particle layers with reverse rotation
            [0.38, 0.46, 0.54, 0.62].forEach((radius, layerIndex) => {
                const particleCount = 90 - layerIndex * 15;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount; i++) {
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = Math.random() * Math.PI * 2;
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({
                    color: 0xFF6B35,
                    size: 0.045 + layerIndex * 0.01,
                    transparent: true,
                    opacity: 0.95 - layerIndex * 0.15,
                    blending: THREE.AdditiveBlending
                });
                const particles = new THREE.Points(geometry, material);
                particles.userData.isParticles = true;
                particles.userData.layerSpeed = layerIndex % 2 === 0 ? 0.25 : -0.25;
                group.add(particles);
            });

            // Gradient halo with animation
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(128, 128, 45, 128, 128, 128);
            gradient.addColorStop(0, 'rgba(255, 107, 53, 0.6)');
            gradient.addColorStop(0.3, 'rgba(255, 150, 80, 0.4)');
            gradient.addColorStop(0.6, 'rgba(255, 200, 120, 0.2)');
            gradient.addColorStop(1, 'rgba(255, 107, 53, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
            const texture = new THREE.CanvasTexture(canvas);
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.75, 32, 32),
                new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                })
            );
            halo.userData.isPulsing = true;
            halo.userData.largeScale = true;
            halo.userData.rotatingHalo = true;

            const elasticShell = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.3
                })
            );
            elasticShell.userData.isPulsing = true;
            elasticShell.userData.elastic = true;
            elasticShell.userData.spring = true;

            group.add(elasticShell);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function createTheOne(scene) {
            const group = new THREE.Group();

            // Perfect core
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.32, 64, 64),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    emissive: 0xFF6B35,
                    emissiveIntensity: 3.5
                })
            );
            core.userData.isCore = true;
            core.userData.pulseDramatic = true;
            group.add(core);

            // Optimal particle layers (3 layers, balanced)
            [0.42, 0.52, 0.62].forEach((radius, layerIndex) => {
                const particleCount = 85 - layerIndex * 20;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount; i++) {
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = Math.random() * Math.PI * 2;
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({
                    color: 0xFF6B35,
                    size: 0.05 + layerIndex * 0.008,
                    transparent: true,
                    opacity: 0.88 - layerIndex * 0.12,
                    blending: THREE.AdditiveBlending
                });
                const particles = new THREE.Points(geometry, material);
                particles.userData.isParticles = true;
                particles.userData.layerSpeed = layerIndex % 2 === 0 ? 0.22 : -0.18;
                group.add(particles);
            });

            // Perfect gradient halo
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(128, 128, 48, 128, 128, 128);
            gradient.addColorStop(0, 'rgba(255, 107, 53, 0.55)');
            gradient.addColorStop(0.35, 'rgba(255, 170, 90, 0.35)');
            gradient.addColorStop(0.65, 'rgba(255, 200, 130, 0.18)');
            gradient.addColorStop(1, 'rgba(255, 107, 53, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
            const texture = new THREE.CanvasTexture(canvas);
            const halo = new THREE.Mesh(
                new THREE.SphereGeometry(0.72, 32, 32),
                new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                })
            );
            halo.userData.isPulsing = true;
            halo.userData.largeScale = true;

            // Subtle elastic shell
            const elasticShell = new THREE.Mesh(
                new THREE.SphereGeometry(0.38, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xFF6B35,
                    transparent: true,
                    opacity: 0.28
                })
            );
            elasticShell.userData.isPulsing = true;
            elasticShell.userData.elastic = true;
            elasticShell.userData.gentle = true;

            group.add(elasticShell);
            group.add(halo);
            scene.add(group);
            return group;
        }

        function setupScene(canvas) {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(50, canvas.width / canvas.height, 0.1, 100);
            camera.position.set(0, 0, 3);

            const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.setSize(canvas.width, canvas.height);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);

            return { scene, camera, renderer };
        }

        function animate(sceneData, sphereGroup) {
            const time = performance.now() * 0.001;

            sphereGroup.traverse(child => {
                if (child.userData.isCore) {
                    const pulseSpeed = child.userData.pulseFast ? 2.0 : 1.2;
                    let minIntensity = 1.0;
                    let maxIntensity = 3.0;

                    if (child.userData.pulseDramatic) {
                        minIntensity = 0.2;
                        maxIntensity = 4.0;
                    }

                    const intensity = minIntensity + (maxIntensity - minIntensity) *
                                    (0.5 + 0.5 * Math.sin(time * pulseSpeed));
                    if (child.material.emissive) {
                        child.material.emissiveIntensity = intensity;
                    }
                }

                if (child.userData.isPulsing) {
                    let pulseAmount = 0.15;
                    let pulseSpeed = 1.2;

                    if (child.userData.largeScale) pulseAmount = 0.25;
                    if (child.userData.wobble) {
                        child.scale.x = 1.0 + Math.sin(time * 1.2) * 0.15;
                        child.scale.y = 1.0 + Math.sin(time * 1.4) * 0.15;
                        child.scale.z = 1.0 + Math.sin(time * 1.1) * 0.15;
                        return;
                    }
                    if (child.userData.elastic) {
                        pulseAmount = 0.3;
                        pulseSpeed = 0.8;

                        // Set 3 elastic variations
                        if (child.userData.fastSpeed) {
                            pulseSpeed = 1.5;
                        } else if (child.userData.gentle) {
                            pulseAmount = 0.2;
                            pulseSpeed = 0.5;
                        } else if (child.userData.extreme) {
                            pulseAmount = 0.5;
                        } else if (child.userData.damped) {
                            const decay = Math.exp(-time * 0.2);
                            pulseAmount = 0.3 * (0.5 + 0.5 * decay);
                        } else if (child.userData.spring) {
                            // Spring effect: sin(t) * exp(-damping*t)
                            const damping = 0.3;
                            const decay = Math.exp(-damping * (time % 10));
                            pulseAmount = 0.4 * decay;
                            pulseSpeed = 2.0;
                        }
                    }
                    if (child.userData.breath) {
                        pulseAmount = 0.1;
                        pulseSpeed = 0.6;
                    }

                    const scale = 1.0 + Math.sin(time * pulseSpeed) * pulseAmount;
                    child.scale.setScalar(scale);
                }

                if (child.userData.isParticles) {
                    if (child.userData.slowMotion) {
                        child.rotation.y = time * 0.1;
                    } else if (child.userData.flowPattern) {
                        child.rotation.y = time * 0.5;
                    } else if (child.userData.burstPattern) {
                        const scale = 1.0 + Math.sin(time * 1.5) * 0.3;
                        child.scale.setScalar(scale);
                    } else if (child.userData.rotating) {
                        // Set 3: Rotating shell particles
                        child.rotation.x = time * 0.4;
                        child.rotation.y = time * 0.3;
                    } else if (child.userData.radialPulse) {
                        // Set 3: Pulsing shell particles
                        const scale = 1.0 + Math.sin(time * 1.2) * 0.2;
                        child.scale.setScalar(scale);
                    } else if (child.userData.layerSpeed) {
                        // Set 3: Layered shell with per-layer speed
                        child.rotation.y = time * child.userData.layerSpeed;
                    } else {
                        child.rotation.x = time * 0.3;
                        child.rotation.y = time * 0.2;
                    }
                }

                if (child.userData.isRing) {
                    if (child.userData.rotating) {
                        child.rotation.z += 0.01;
                    }
                    if (child.userData.glowing && child.material.emissive) {
                        const intensity = 1.5 + Math.sin(time * 1.2) * 0.8;
                        child.material.emissiveIntensity = intensity;
                    }
                }
            });

            sphereGroup.rotation.y += 0.005;

            sceneData.renderer.render(sceneData.scene, sceneData.camera);
        }

        function loadSet(setIndex) {
            currentSetIndex = setIndex;
            const set = designSets[setIndex];

            // Clear existing scenes
            activeScenes.forEach(data => {
                data.renderer.dispose();
            });
            activeScenes = [];

            // Clear grid
            const gridContainer = document.getElementById('grid-container');
            gridContainer.innerHTML = '';

            // Update header
            document.getElementById('current-set').textContent = setIndex + 1;
            document.getElementById('total-sets').textContent = designSets.length;

            // Update navigation buttons
            document.getElementById('prev-set-btn').disabled = setIndex === 0;
            document.getElementById('next-set-btn').disabled = setIndex === designSets.length - 1;

            // Create cards for current set
            set.designs.forEach(design => {
                const card = document.createElement('div');
                card.className = 'sphere-card';
                card.dataset.id = design.id;

                const badge = document.createElement('div');
                badge.className = 'selection-badge';
                badge.textContent = '‚úì';

                const canvas = document.createElement('canvas');
                canvas.width = 400;
                canvas.height = 400;

                const info = document.createElement('div');
                info.className = 'sphere-info';
                info.innerHTML = `
                    <div class="sphere-id">${design.id}</div>
                    <div class="sphere-name">${design.name}</div>
                    <div class="sphere-tech">${design.tech}</div>
                `;

                card.appendChild(badge);
                card.appendChild(canvas);
                card.appendChild(info);
                gridContainer.appendChild(card);

                const sceneData = setupScene(canvas);
                const sphereGroup = design.create(sceneData.scene);
                activeScenes.push({ ...sceneData, sphereGroup, canvas, id: design.id });

                card.addEventListener('click', () => {
                    card.classList.toggle('selected');
                    if (card.classList.contains('selected')) {
                        selectedDesigns.add(design.id);
                    } else {
                        selectedDesigns.delete(design.id);
                    }
                    updateSelectionCount();
                });
            });

            // Clear selection for new set
            selectedDesigns.clear();
            updateSelectionCount();
        }

        function updateSelectionCount() {
            const count = selectedDesigns.size;
            document.getElementById('selected-count').textContent = count;
            document.getElementById('show-selected-btn').disabled = count === 0;
        }

        // Animation loop
        function render() {
            activeScenes.forEach(data => {
                animate(data, data.sphereGroup);
            });
            requestAnimationFrame(render);
        }

        // Event listeners
        document.getElementById('prev-set-btn').addEventListener('click', () => {
            if (currentSetIndex > 0) {
                loadSet(currentSetIndex - 1);
            }
        });

        document.getElementById('next-set-btn').addEventListener('click', () => {
            if (currentSetIndex < designSets.length - 1) {
                loadSet(currentSetIndex + 1);
            }
        });

        document.getElementById('clear-btn').addEventListener('click', () => {
            selectedDesigns.clear();
            document.querySelectorAll('.sphere-card').forEach(card => {
                card.classList.remove('selected');
            });
            updateSelectionCount();
        });

        document.getElementById('show-selected-btn').addEventListener('click', () => {
            const ids = Array.from(selectedDesigns).join(', ');
            alert(`Selected designs: ${ids}`);
        });

        document.getElementById('back-game-btn').addEventListener('click', () => {
            window.location.href = 'index.html';
        });

        // Initialize
        loadSet(0);
        render();
    </script>
</body>
</html>
